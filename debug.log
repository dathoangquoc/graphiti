2025-05-15 17:15:42,858 - CRITICAL - Current model llama3.2:1b-instruct-q2_K: 
2025-05-15 17:15:42,878 - INFO - Use pytorch device_name: cpu
2025-05-15 17:15:42,878 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-05-15 17:15:45,624 - INFO - Use pytorch device_name: cpu
2025-05-15 17:15:45,624 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-05-15 17:15:48,496 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX entity_uuid IF NOT EXISTS FOR (e:Entity) ON (e.uuid)` has no effect.} {description: `RANGE INDEX entity_uuid FOR (e:Entity) ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX entity_uuid IF NOT EXISTS FOR (n:Entity) ON (n.uuid)'
2025-05-15 17:15:48,498 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX episode_uuid IF NOT EXISTS FOR (e:Episodic) ON (e.uuid)` has no effect.} {description: `RANGE INDEX episode_uuid FOR (e:Episodic) ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX episode_uuid IF NOT EXISTS FOR (n:Episodic) ON (n.uuid)'
2025-05-15 17:15:48,502 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX community_uuid IF NOT EXISTS FOR (e:Community) ON (e.uuid)` has no effect.} {description: `RANGE INDEX community_uuid FOR (e:Community) ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX community_uuid IF NOT EXISTS FOR (n:Community) ON (n.uuid)'
2025-05-15 17:15:48,504 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX relation_uuid IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.uuid)` has no effect.} {description: `RANGE INDEX relation_uuid FOR ()-[e:RELATES_TO]-() ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX relation_uuid IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.uuid)'
2025-05-15 17:15:48,504 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX mention_uuid IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.uuid)` has no effect.} {description: `RANGE INDEX mention_uuid FOR ()-[e:MENTIONS]-() ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX mention_uuid IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.uuid)'
2025-05-15 17:15:48,505 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX has_member_uuid IF NOT EXISTS FOR ()-[e:HAS_MEMBER]-() ON (e.uuid)` has no effect.} {description: `RANGE INDEX has_member_uuid FOR ()-[e:HAS_MEMBER]-() ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX has_member_uuid IF NOT EXISTS FOR ()-[e:HAS_MEMBER]-() ON (e.uuid)'
2025-05-15 17:15:48,506 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX name_entity_index IF NOT EXISTS FOR (e:Entity) ON (e.name)` has no effect.} {description: `RANGE INDEX name_entity_index FOR (e:Entity) ON (e.name)` already exists.} {position: None} for query: 'CREATE INDEX name_entity_index IF NOT EXISTS FOR (n:Entity) ON (n.name)'
2025-05-15 17:15:48,506 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX episode_group_id IF NOT EXISTS FOR (e:Episodic) ON (e.group_id)` has no effect.} {description: `RANGE INDEX episode_group_id FOR (e:Episodic) ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX episode_group_id IF NOT EXISTS FOR (n:Episodic) ON (n.group_id)'
2025-05-15 17:15:48,507 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX entity_group_id IF NOT EXISTS FOR (e:Entity) ON (e.group_id)` has no effect.} {description: `RANGE INDEX entity_group_id FOR (e:Entity) ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX entity_group_id IF NOT EXISTS FOR (n:Entity) ON (n.group_id)'
2025-05-15 17:15:48,507 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX relation_group_id IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.group_id)` has no effect.} {description: `RANGE INDEX relation_group_id FOR ()-[e:RELATES_TO]-() ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX relation_group_id IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.group_id)'
2025-05-15 17:15:48,508 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX mention_group_id IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.group_id)` has no effect.} {description: `RANGE INDEX mention_group_id FOR ()-[e:MENTIONS]-() ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX mention_group_id IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.group_id)'
2025-05-15 17:15:48,508 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX valid_at_episodic_index IF NOT EXISTS FOR (e:Episodic) ON (e.valid_at)` has no effect.} {description: `RANGE INDEX valid_at_episodic_index FOR (e:Episodic) ON (e.valid_at)` already exists.} {position: None} for query: 'CREATE INDEX valid_at_episodic_index IF NOT EXISTS FOR (n:Episodic) ON (n.valid_at)'
2025-05-15 17:15:48,509 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX created_at_episodic_index IF NOT EXISTS FOR (e:Episodic) ON (e.created_at)` has no effect.} {description: `RANGE INDEX created_at_episodic_index FOR (e:Episodic) ON (e.created_at)` already exists.} {position: None} for query: 'CREATE INDEX created_at_episodic_index IF NOT EXISTS FOR (n:Episodic) ON (n.created_at)'
2025-05-15 17:15:48,509 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX created_at_entity_index IF NOT EXISTS FOR (e:Entity) ON (e.created_at)` has no effect.} {description: `RANGE INDEX created_at_entity_index FOR (e:Entity) ON (e.created_at)` already exists.} {position: None} for query: 'CREATE INDEX created_at_entity_index IF NOT EXISTS FOR (n:Entity) ON (n.created_at)'
2025-05-15 17:15:48,510 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX expired_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.expired_at)` has no effect.} {description: `RANGE INDEX expired_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.expired_at)` already exists.} {position: None} for query: 'CREATE INDEX expired_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.expired_at)'
2025-05-15 17:15:48,510 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX created_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.created_at)` has no effect.} {description: `RANGE INDEX created_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.created_at)` already exists.} {position: None} for query: 'CREATE INDEX created_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.created_at)'
2025-05-15 17:15:48,511 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX invalid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.invalid_at)` has no effect.} {description: `RANGE INDEX invalid_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.invalid_at)` already exists.} {position: None} for query: 'CREATE INDEX invalid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.invalid_at)'
2025-05-15 17:15:48,511 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX name_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.name)` has no effect.} {description: `RANGE INDEX name_edge_index FOR ()-[e:RELATES_TO]-() ON (e.name)` already exists.} {position: None} for query: 'CREATE INDEX name_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.name)'
2025-05-15 17:15:48,512 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX valid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.valid_at)` has no effect.} {description: `RANGE INDEX valid_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.valid_at)` already exists.} {position: None} for query: 'CREATE INDEX valid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.valid_at)'
2025-05-15 17:15:48,512 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX episode_content IF NOT EXISTS FOR (e:Episodic) ON EACH [e.content, e.source, e.source_description, e.group_id]` has no effect.} {description: `FULLTEXT INDEX episode_content FOR (e:Episodic) ON EACH [e.content, e.source, e.source_description, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX episode_content IF NOT EXISTS \n        FOR (e:Episodic) ON EACH [e.content, e.source, e.source_description, e.group_id]'
2025-05-15 17:15:48,516 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX node_name_and_summary IF NOT EXISTS FOR (e:Entity) ON EACH [e.name, e.summary, e.group_id]` has no effect.} {description: `FULLTEXT INDEX node_name_and_summary FOR (e:Entity) ON EACH [e.name, e.summary, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX node_name_and_summary IF NOT EXISTS \n        FOR (n:Entity) ON EACH [n.name, n.summary, n.group_id]'
2025-05-15 17:15:48,517 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX community_name IF NOT EXISTS FOR (e:Community) ON EACH [e.name, e.group_id]` has no effect.} {description: `FULLTEXT INDEX community_name FOR (e:Community) ON EACH [e.name, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX community_name IF NOT EXISTS \n        FOR (n:Community) ON EACH [n.name, n.group_id]'
2025-05-15 17:15:48,517 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX edge_name_and_fact IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON EACH [e.name, e.fact, e.group_id]` has no effect.} {description: `FULLTEXT INDEX edge_name_and_fact FOR ()-[e:RELATES_TO]-() ON EACH [e.name, e.fact, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX edge_name_and_fact IF NOT EXISTS \n        FOR ()-[e:RELATES_TO]-() ON EACH [e.name, e.fact, e.group_id]'
2025-05-15 17:15:48,527 - WARNING - Request: [{'role': 'system', 'content': 'You are an AI assistant that extracts entity nodes from text. \n    Your primary task is to extract and classify the speaker and other significant entities mentioned in the provided text.\nDo not escape unicode characters.\n\n\nAny extracted information should be returned in the same language as it was written in.'}, {'role': 'user', 'content': '\n<TEXT>\nKamala Harris is the Attorney General of California. She was previously the district attorney for San Francisco.\n</TEXT>\n<ENTITY TYPES>\n[{\'entity_type_id\': 0, \'entity_type_name\': \'Entity\', \'entity_type_description\': \'Default entity classification. Use this entity type if the entity is not one of the other listed types.\'}]\n</ENTITY TYPES>\n\nGiven the above text, extract entities from the TEXT that are explicitly or implicitly mentioned.\nFor each entity extracted, also determine its entity type based on the provided ENTITY TYPES and their descriptions.\nIndicate the classified entity type by providing its entity_type_id.\n\n\n\nGuidelines:\n1. Extract significant entities, concepts, or actors mentioned in the conversation.\n2. Avoid creating nodes for relationships or actions.\n3. Avoid creating nodes for temporal information like dates, times or years (these will be added to edges later).\n4. Be as explicit as possible in your node names, using full names and avoiding abbreviations.\n\n\nRespond with a JSON object in the following format:\n\n{"$defs": {"ExtractedEntity": {"properties": {"name": {"description": "Name of the extracted entity", "title": "Name", "type": "string"}, "entity_type_id": {"description": "ID of the classified entity type. Must be one of the provided entity_type_id integers.", "title": "Entity Type Id", "type": "integer"}}, "required": ["name", "entity_type_id"], "title": "ExtractedEntity", "type": "object"}}, "properties": {"extracted_entities": {"description": "List of extracted entities", "items": {"$ref": "#/$defs/ExtractedEntity"}, "title": "Extracted Entities", "type": "array"}}, "required": ["extracted_entities"], "title": "ExtractedEntities", "type": "object"}'}]
2025-05-15 17:28:53,038 - CRITICAL - Current model llama3.2:3b: 
2025-05-15 17:28:53,058 - INFO - Use pytorch device_name: cpu
2025-05-15 17:28:53,058 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-05-15 17:28:56,033 - INFO - Use pytorch device_name: cpu
2025-05-15 17:28:56,033 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-05-15 17:28:58,905 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX episode_uuid IF NOT EXISTS FOR (e:Episodic) ON (e.uuid)` has no effect.} {description: `RANGE INDEX episode_uuid FOR (e:Episodic) ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX episode_uuid IF NOT EXISTS FOR (n:Episodic) ON (n.uuid)'
2025-05-15 17:28:58,905 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX community_uuid IF NOT EXISTS FOR (e:Community) ON (e.uuid)` has no effect.} {description: `RANGE INDEX community_uuid FOR (e:Community) ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX community_uuid IF NOT EXISTS FOR (n:Community) ON (n.uuid)'
2025-05-15 17:28:58,906 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX entity_uuid IF NOT EXISTS FOR (e:Entity) ON (e.uuid)` has no effect.} {description: `RANGE INDEX entity_uuid FOR (e:Entity) ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX entity_uuid IF NOT EXISTS FOR (n:Entity) ON (n.uuid)'
2025-05-15 17:28:58,908 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX node_name_and_summary IF NOT EXISTS FOR (e:Entity) ON EACH [e.name, e.summary, e.group_id]` has no effect.} {description: `FULLTEXT INDEX node_name_and_summary FOR (e:Entity) ON EACH [e.name, e.summary, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX node_name_and_summary IF NOT EXISTS \n        FOR (n:Entity) ON EACH [n.name, n.summary, n.group_id]'
2025-05-15 17:28:58,909 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX mention_group_id IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.group_id)` has no effect.} {description: `RANGE INDEX mention_group_id FOR ()-[e:MENTIONS]-() ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX mention_group_id IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.group_id)'
2025-05-15 17:28:58,911 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX mention_uuid IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.uuid)` has no effect.} {description: `RANGE INDEX mention_uuid FOR ()-[e:MENTIONS]-() ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX mention_uuid IF NOT EXISTS FOR ()-[e:MENTIONS]-() ON (e.uuid)'
2025-05-15 17:28:58,912 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX entity_group_id IF NOT EXISTS FOR (e:Entity) ON (e.group_id)` has no effect.} {description: `RANGE INDEX entity_group_id FOR (e:Entity) ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX entity_group_id IF NOT EXISTS FOR (n:Entity) ON (n.group_id)'
2025-05-15 17:28:58,912 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX community_name IF NOT EXISTS FOR (e:Community) ON EACH [e.name, e.group_id]` has no effect.} {description: `FULLTEXT INDEX community_name FOR (e:Community) ON EACH [e.name, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX community_name IF NOT EXISTS \n        FOR (n:Community) ON EACH [n.name, n.group_id]'
2025-05-15 17:28:58,912 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX has_member_uuid IF NOT EXISTS FOR ()-[e:HAS_MEMBER]-() ON (e.uuid)` has no effect.} {description: `RANGE INDEX has_member_uuid FOR ()-[e:HAS_MEMBER]-() ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX has_member_uuid IF NOT EXISTS FOR ()-[e:HAS_MEMBER]-() ON (e.uuid)'
2025-05-15 17:28:58,912 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX relation_uuid IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.uuid)` has no effect.} {description: `RANGE INDEX relation_uuid FOR ()-[e:RELATES_TO]-() ON (e.uuid)` already exists.} {position: None} for query: 'CREATE INDEX relation_uuid IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.uuid)'
2025-05-15 17:28:58,913 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX relation_group_id IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.group_id)` has no effect.} {description: `RANGE INDEX relation_group_id FOR ()-[e:RELATES_TO]-() ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX relation_group_id IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.group_id)'
2025-05-15 17:28:58,914 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX name_entity_index IF NOT EXISTS FOR (e:Entity) ON (e.name)` has no effect.} {description: `RANGE INDEX name_entity_index FOR (e:Entity) ON (e.name)` already exists.} {position: None} for query: 'CREATE INDEX name_entity_index IF NOT EXISTS FOR (n:Entity) ON (n.name)'
2025-05-15 17:28:58,914 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX episode_group_id IF NOT EXISTS FOR (e:Episodic) ON (e.group_id)` has no effect.} {description: `RANGE INDEX episode_group_id FOR (e:Episodic) ON (e.group_id)` already exists.} {position: None} for query: 'CREATE INDEX episode_group_id IF NOT EXISTS FOR (n:Episodic) ON (n.group_id)'
2025-05-15 17:28:58,914 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX created_at_episodic_index IF NOT EXISTS FOR (e:Episodic) ON (e.created_at)` has no effect.} {description: `RANGE INDEX created_at_episodic_index FOR (e:Episodic) ON (e.created_at)` already exists.} {position: None} for query: 'CREATE INDEX created_at_episodic_index IF NOT EXISTS FOR (n:Episodic) ON (n.created_at)'
2025-05-15 17:28:58,914 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX name_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.name)` has no effect.} {description: `RANGE INDEX name_edge_index FOR ()-[e:RELATES_TO]-() ON (e.name)` already exists.} {position: None} for query: 'CREATE INDEX name_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.name)'
2025-05-15 17:28:58,915 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX created_at_entity_index IF NOT EXISTS FOR (e:Entity) ON (e.created_at)` has no effect.} {description: `RANGE INDEX created_at_entity_index FOR (e:Entity) ON (e.created_at)` already exists.} {position: None} for query: 'CREATE INDEX created_at_entity_index IF NOT EXISTS FOR (n:Entity) ON (n.created_at)'
2025-05-15 17:28:58,915 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX invalid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.invalid_at)` has no effect.} {description: `RANGE INDEX invalid_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.invalid_at)` already exists.} {position: None} for query: 'CREATE INDEX invalid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.invalid_at)'
2025-05-15 17:28:58,915 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX valid_at_episodic_index IF NOT EXISTS FOR (e:Episodic) ON (e.valid_at)` has no effect.} {description: `RANGE INDEX valid_at_episodic_index FOR (e:Episodic) ON (e.valid_at)` already exists.} {position: None} for query: 'CREATE INDEX valid_at_episodic_index IF NOT EXISTS FOR (n:Episodic) ON (n.valid_at)'
2025-05-15 17:28:58,915 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX valid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.valid_at)` has no effect.} {description: `RANGE INDEX valid_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.valid_at)` already exists.} {position: None} for query: 'CREATE INDEX valid_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.valid_at)'
2025-05-15 17:28:58,917 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX edge_name_and_fact IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON EACH [e.name, e.fact, e.group_id]` has no effect.} {description: `FULLTEXT INDEX edge_name_and_fact FOR ()-[e:RELATES_TO]-() ON EACH [e.name, e.fact, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX edge_name_and_fact IF NOT EXISTS \n        FOR ()-[e:RELATES_TO]-() ON EACH [e.name, e.fact, e.group_id]'
2025-05-15 17:28:58,917 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX created_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.created_at)` has no effect.} {description: `RANGE INDEX created_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.created_at)` already exists.} {position: None} for query: 'CREATE INDEX created_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.created_at)'
2025-05-15 17:28:58,917 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE FULLTEXT INDEX episode_content IF NOT EXISTS FOR (e:Episodic) ON EACH [e.content, e.source, e.source_description, e.group_id]` has no effect.} {description: `FULLTEXT INDEX episode_content FOR (e:Episodic) ON EACH [e.content, e.source, e.source_description, e.group_id]` already exists.} {position: None} for query: 'CREATE FULLTEXT INDEX episode_content IF NOT EXISTS \n        FOR (e:Episodic) ON EACH [e.content, e.source, e.source_description, e.group_id]'
2025-05-15 17:28:58,917 - INFO - Received notification from DBMS server: {severity: INFORMATION} {code: Neo.ClientNotification.Schema.IndexOrConstraintAlreadyExists} {category: SCHEMA} {title: `CREATE RANGE INDEX expired_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.expired_at)` has no effect.} {description: `RANGE INDEX expired_at_edge_index FOR ()-[e:RELATES_TO]-() ON (e.expired_at)` already exists.} {position: None} for query: 'CREATE INDEX expired_at_edge_index IF NOT EXISTS FOR ()-[e:RELATES_TO]-() ON (e.expired_at)'
2025-05-15 17:28:58,923 - WARNING - Request: [{'role': 'system', 'content': 'You are an AI assistant that extracts entity nodes from text. \n    Your primary task is to extract and classify the speaker and other significant entities mentioned in the provided text.\nDo not escape unicode characters.\n\n\nAny extracted information should be returned in the same language as it was written in.'}, {'role': 'user', 'content': '\n<TEXT>\nKamala Harris is the Attorney General of California. She was previously the district attorney for San Francisco.\n</TEXT>\n<ENTITY TYPES>\n[{\'entity_type_id\': 0, \'entity_type_name\': \'Entity\', \'entity_type_description\': \'Default entity classification. Use this entity type if the entity is not one of the other listed types.\'}]\n</ENTITY TYPES>\n\nGiven the above text, extract entities from the TEXT that are explicitly or implicitly mentioned.\nFor each entity extracted, also determine its entity type based on the provided ENTITY TYPES and their descriptions.\nIndicate the classified entity type by providing its entity_type_id.\n\n\n\nGuidelines:\n1. Extract significant entities, concepts, or actors mentioned in the conversation.\n2. Avoid creating nodes for relationships or actions.\n3. Avoid creating nodes for temporal information like dates, times or years (these will be added to edges later).\n4. Be as explicit as possible in your node names, using full names and avoiding abbreviations.\n\n\nRespond with a JSON object in the following format:\n\n{"$defs": {"ExtractedEntity": {"properties": {"name": {"description": "Name of the extracted entity", "title": "Name", "type": "string"}, "entity_type_id": {"description": "ID of the classified entity type. Must be one of the provided entity_type_id integers.", "title": "Entity Type Id", "type": "integer"}}, "required": ["name", "entity_type_id"], "title": "ExtractedEntity", "type": "object"}}, "properties": {"extracted_entities": {"description": "List of extracted entities", "items": {"$ref": "#/$defs/ExtractedEntity"}, "title": "Extracted Entities", "type": "array"}}, "required": ["extracted_entities"], "title": "ExtractedEntities", "type": "object"}'}]
2025-05-15 17:29:23,608 - INFO - HTTP Request: POST http://localhost:11434/v1/chat/completions "HTTP/1.1 200 OK"
2025-05-15 17:29:23,609 - WARNING - Response: {"$defs": {"ExtractedEntity": {"properties": {"name": {"description": "Name of the extracted entity", "title": "Name", "type": "string"}, "entity_type_id": {"description": "ID of the classified entity type. Must be one of the provided entity_type_id integers.", "title": "Entity Type Id", "type": "integer"}}, "required": ["name", "entity_type_id"], "title": "ExtractedEntity", "type": "object"}}, "properties": {"extracted_entities": {"description": "List of extracted entities", "items": {"$ref": "#/$defs/ExtractedEntity"}, "title": "Extracted Entities", "type": "array"}},"extracted_entities": [{"name": "Kamala Harris", "entity_type_id": 0}]}
2025-05-15 17:29:23,624 - WARNING - Request: [{'role': 'system', 'content': 'You are an expert fact extractor that extracts fact triples from text. 1. Extracted fact triples should also be extracted with relevant date information.2. Treat the CURRENT TIME as the time the CURRENT MESSAGE was sent. All temporal information should be extracted relative to this time.\nDo not escape unicode characters.\n\n\nAny extracted information should be returned in the same language as it was written in.'}, {'role': 'user', 'content': '\n<PREVIOUS_MESSAGES>\n[\n  "Kamala Harris is the Attorney General of California. She was previously the district attorney for San Francisco.",\n  "As AG, Harris was in office from January 3, 2011 \\u2013 January 3, 2017"\n]\n</PREVIOUS_MESSAGES>\n\n<CURRENT_MESSAGE>\nKamala Harris is the Attorney General of California. She was previously the district attorney for San Francisco.\n</CURRENT_MESSAGE>\n\n<ENTITIES>\n[\'Kamala Harris\']  # Each has: id, label (e.g., Person, Org), name, aliases\n</ENTITIES>\n\n<REFERENCE_TIME>\n2025-05-15 10:28:58.918612+00:00  # ISO 8601 (UTC); used to resolve relative time mentions\n</REFERENCE_TIME>\n\n# TASK\nExtract all factual relationships between the given ENTITIES based on the CURRENT MESSAGE.\nOnly extract facts that:\n- involve two DISTINCT ENTITIES from the ENTITIES list,\n- are clearly stated or unambiguously implied in the CURRENT MESSAGE,\n- and can be represented as edges in a knowledge graph.\n\nYou may use information from the PREVIOUS MESSAGES only to disambiguate references or support continuity.\n\n\n\n\n# EXTRACTION RULES\n\n1. Only emit facts where both the subject and object match IDs in ENTITIES.\n2. Each fact must involve two **distinct** entities.\n3. Use a SCREAMING_SNAKE_CASE string as the `relation_type` (e.g., FOUNDED, WORKS_AT).\n4. Do not emit duplicate or semantically redundant facts.\n5. The `fact_text` should quote or closely paraphrase the original source sentence(s).\n6. Use `REFERENCE_TIME` to resolve vague or relative temporal expressions (e.g., "last week").\n7. Do **not** hallucinate or infer temporal bounds from unrelated events.\n\n# DATETIME RULES\n\n- Use ISO 8601 with “Z” suffix (UTC) (e.g., 2025-04-30T00:00:00Z).\n- If the fact is ongoing (present tense), set `valid_at` to REFERENCE_TIME.\n- If a change/termination is expressed, set `invalid_at` to the relevant timestamp.\n- Leave both fields `null` if no explicit or resolvable time is stated.\n- If only a date is mentioned (no time), assume 00:00:00.\n- If only a year is mentioned, use January 1st at 00:00:00.\n        \n\nRespond with a JSON object in the following format:\n\n{"$defs": {"Edge": {"properties": {"relation_type": {"description": "FACT_PREDICATE_IN_SCREAMING_SNAKE_CASE", "title": "Relation Type", "type": "string"}, "source_entity_name": {"description": "The name of the source entity of the fact.", "title": "Source Entity Name", "type": "string"}, "target_entity_name": {"description": "The name of the target entity of the fact.", "title": "Target Entity Name", "type": "string"}, "fact": {"description": "", "title": "Fact", "type": "string"}, "valid_at": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The date and time when the relationship described by the edge fact became true or was established. Use ISO 8601 format (YYYY-MM-DDTHH:MM:SS.SSSSSSZ)", "title": "Valid At"}, "invalid_at": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The date and time when the relationship described by the edge fact stopped being true or ended. Use ISO 8601 format (YYYY-MM-DDTHH:MM:SS.SSSSSSZ)", "title": "Invalid At"}}, "required": ["relation_type", "source_entity_name", "target_entity_name", "fact"], "title": "Edge", "type": "object"}}, "properties": {"edges": {"items": {"$ref": "#/$defs/Edge"}, "title": "Edges", "type": "array"}}, "required": ["edges"], "title": "ExtractedEdges", "type": "object"}'}]
2025-05-15 17:29:23,675 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 4, column: 48, offset: 120} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:29:23,675 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 284} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:29:23,677 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 371} for query: '\n                                        CALL db.index.fulltext.queryNodes("node_name_and_summary", $query, {limit: $limit}) \n                                        YIELD node AS n, score\n                                        WHERE n:Entity\n                                        \n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        '
2025-05-15 17:30:19,646 - INFO - HTTP Request: POST http://localhost:11434/v1/chat/completions "HTTP/1.1 200 OK"
2025-05-15 17:30:19,646 - WARNING - Response: {"$defs": {"Edge": {"properties": {"relation_type": {"description": "FACT_PREDICATE_IN_SCREAMING_SNAKE_CASE", "title": "Relation Type", "type": "string"}, "source_entity_name": {"description": "The name of the source entity of the fact.", "title": "Source Entity Name", "type": "string"}, "target_entity_name": {"description": "The name of the target entity of the fact.", "title": "Target Entity Name", "type": "string"}, "fact": {"description": "", "title": "Fact", "type": "string"}, "valid_at": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The date and time when the relationship described by the edge fact became true or was established. Use ISO 8601 format (YYYY-MM-DDTHH:MM:SS.SSSSSSZ)", "title": "Valid At"}, "invalid_at": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "description": "The date and time when the relationship described by the edge fact stopped being true or ended. Use ISO 8601 format (YYYY-MM-DDTHH:MM:SS.SSSSSSZ)", "title": "Invalid At"}}, "required": ["relation_type", "source_entity_name", "target_entity_name", "fact"], "title": "Edge", "type": "object"}, "properties": {"edges": {"items": {"$ref": "#/$defs/Edge"}, "title": "Edges", "type": "array"}}}, "properties": {"edges": {"items": {"$ref": "#/$defs/Edge"}, "title": "ExtractedEdges", "type": "array"}}}
2025-05-15 17:30:19,647 - WARNING - Request: [{'role': 'system', 'content': 'You are a helpful assistant that extracts entity properties from the provided text.\nDo not escape unicode characters.\n\n\nAny extracted information should be returned in the same language as it was written in.'}, {'role': 'user', 'content': '\n\n        <MESSAGES>\n        [\n  "Kamala Harris is the Attorney General of California. She was previously the district attorney for San Francisco.",\n  "As AG, Harris was in office from January 3, 2011 \\u2013 January 3, 2017"\n]\n        "Kamala Harris is the Attorney General of California. She was previously the district attorney for San Francisco."\n        </MESSAGES>\n\n        Given the above MESSAGES and the following ENTITY, update any of its attributes based on the information provided\n        in MESSAGES. Use the provided attribute descriptions to better understand how each attribute should be determined.\n\n        Guidelines:\n        1. Do not hallucinate entity property values if they cannot be found in the current context.\n        2. Only use the provided MESSAGES and ENTITY to set attribute values.\n        3. The summary attribute represents a summary of the ENTITY, and should be updated with new information about the Entity from the MESSAGES. \n            Summaries must be no longer than 500 words.\n        \n        <ENTITY>\n        {\'name\': \'Kamala Harris\', \'summary\': \'\', \'entity_types\': [\'Entity\'], \'attributes\': {}}\n        </ENTITY>\n        \n\nRespond with a JSON object in the following format:\n\n{"properties": {"summary": {"description": "Summary containing the important information about the entity. Under 500 words", "title": "Summary", "type": "string"}}, "required": ["summary"], "title": "EntityAttributes", "type": "object"}'}]
2025-05-15 17:30:32,276 - INFO - HTTP Request: POST http://localhost:11434/v1/chat/completions "HTTP/1.1 200 OK"
2025-05-15 17:30:32,277 - WARNING - Response: {
  "properties": {
    "summary": {
      "description": "Summary containing the important information about the entity. Under 500 words",
      "title": "Summary",
      "type": "string"
    }
  },
  "required": ["summary"],
  "title": "EntityAttributes",
  "type": "object"
}
2025-05-15 17:39:19,542 - CRITICAL - Current model GEMINI
2025-05-15 17:39:19,576 - INFO - Use pytorch device_name: cpu
2025-05-15 17:39:19,576 - INFO - Load pretrained SentenceTransformer: all-MiniLM-L6-v2
2025-05-15 17:39:22,860 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:24,146 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:24,622 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:24,628 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:24,722 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 4, column: 48, offset: 120} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:39:24,722 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 284} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:39:24,722 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 4, column: 48, offset: 120} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:39:24,722 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 284} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:39:24,722 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 4, column: 48, offset: 120} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:39:24,723 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 284} for query: '\n            MATCH (n:Entity)\n            WHERE n.group_id IN $group_ids\n            WITH n, vector.similarity.cosine(n.name_embedding, $search_vector) AS score\n            WHERE score > $min_score\n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        LIMIT $limit\n        '
2025-05-15 17:39:24,741 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 371} for query: '\n                                        CALL db.index.fulltext.queryNodes("node_name_and_summary", $query, {limit: $limit}) \n                                        YIELD node AS n, score\n                                        WHERE n:Entity\n                                        \n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        '
2025-05-15 17:39:24,742 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 371} for query: '\n                                        CALL db.index.fulltext.queryNodes("node_name_and_summary", $query, {limit: $limit}) \n                                        YIELD node AS n, score\n                                        WHERE n:Entity\n                                        \n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        '
2025-05-15 17:39:24,742 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: name_embedding)} {position: line: 9, column: 15, offset: 371} for query: '\n                                        CALL db.index.fulltext.queryNodes("node_name_and_summary", $query, {limit: $limit}) \n                                        YIELD node AS n, score\n                                        WHERE n:Entity\n                                        \n        RETURN\n            n.uuid As uuid, \n            n.name AS name,\n            n.name_embedding AS name_embedding,\n            n.group_id AS group_id,\n            n.created_at AS created_at, \n            n.summary AS summary,\n            labels(n) AS labels,\n            properties(n) AS attributes\n            \n        ORDER BY score DESC\n        '
2025-05-15 17:39:36,131 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:36,786 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:36,795 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:36,796 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:36,797 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:36,894 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: fact_embedding)} {position: line: 4, column: 54, offset: 221} for query: 'UNWIND $edges AS edge\n    MATCH (n:Entity {uuid: edge.source_node_uuid})-[e:RELATES_TO {group_id: edge.group_id}]-(m:Entity {uuid: edge.target_node_uuid})\n            \n            WITH e, edge, vector.similarity.cosine(e.fact_embedding, edge.fact_embedding) AS score\n            WHERE score > $min_score\n            WITH edge, e, score\n            ORDER BY score DESC\n            RETURN edge.uuid AS search_edge_uuid,\n                collect({\n                    uuid: e.uuid,\n                    source_node_uuid: startNode(e).uuid,\n                    target_node_uuid: endNode(e).uuid,\n                    created_at: e.created_at,\n                    name: e.name,\n                    group_id: e.group_id,\n                    fact: e.fact,\n                    fact_embedding: e.fact_embedding,\n                    episodes: e.episodes,\n                    expired_at: e.expired_at,\n                    valid_at: e.valid_at,\n                    invalid_at: e.invalid_at\n                })[..$limit] AS matches\n        '
2025-05-15 17:39:36,894 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: fact_embedding)} {position: line: 17, column: 39, offset: 784} for query: 'UNWIND $edges AS edge\n    MATCH (n:Entity {uuid: edge.source_node_uuid})-[e:RELATES_TO {group_id: edge.group_id}]-(m:Entity {uuid: edge.target_node_uuid})\n            \n            WITH e, edge, vector.similarity.cosine(e.fact_embedding, edge.fact_embedding) AS score\n            WHERE score > $min_score\n            WITH edge, e, score\n            ORDER BY score DESC\n            RETURN edge.uuid AS search_edge_uuid,\n                collect({\n                    uuid: e.uuid,\n                    source_node_uuid: startNode(e).uuid,\n                    target_node_uuid: endNode(e).uuid,\n                    created_at: e.created_at,\n                    name: e.name,\n                    group_id: e.group_id,\n                    fact: e.fact,\n                    fact_embedding: e.fact_embedding,\n                    episodes: e.episodes,\n                    expired_at: e.expired_at,\n                    valid_at: e.valid_at,\n                    invalid_at: e.invalid_at\n                })[..$limit] AS matches\n        '
2025-05-15 17:39:36,894 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: episodes)} {position: line: 18, column: 33, offset: 832} for query: 'UNWIND $edges AS edge\n    MATCH (n:Entity {uuid: edge.source_node_uuid})-[e:RELATES_TO {group_id: edge.group_id}]-(m:Entity {uuid: edge.target_node_uuid})\n            \n            WITH e, edge, vector.similarity.cosine(e.fact_embedding, edge.fact_embedding) AS score\n            WHERE score > $min_score\n            WITH edge, e, score\n            ORDER BY score DESC\n            RETURN edge.uuid AS search_edge_uuid,\n                collect({\n                    uuid: e.uuid,\n                    source_node_uuid: startNode(e).uuid,\n                    target_node_uuid: endNode(e).uuid,\n                    created_at: e.created_at,\n                    name: e.name,\n                    group_id: e.group_id,\n                    fact: e.fact,\n                    fact_embedding: e.fact_embedding,\n                    episodes: e.episodes,\n                    expired_at: e.expired_at,\n                    valid_at: e.valid_at,\n                    invalid_at: e.invalid_at\n                })[..$limit] AS matches\n        '
2025-05-15 17:39:36,896 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: fact_embedding)} {position: line: 5, column: 54, offset: 289} for query: 'UNWIND $edges AS edge\n    MATCH (n:Entity)-[e:RELATES_TO {group_id: edge.group_id}]->(m:Entity)\n    WHERE n.uuid IN [edge.source_node_uuid, edge.target_node_uuid] OR m.uuid IN [edge.target_node_uuid, edge.source_node_uuid]\n            \n            WITH edge, e, vector.similarity.cosine(e.fact_embedding, edge.fact_embedding) AS score\n            WHERE score > $min_score\n            WITH edge, e, score\n            ORDER BY score DESC\n            RETURN edge.uuid AS search_edge_uuid,\n                collect({\n                    uuid: e.uuid,\n                    source_node_uuid: startNode(e).uuid,\n                    target_node_uuid: endNode(e).uuid,\n                    created_at: e.created_at,\n                    name: e.name,\n                    group_id: e.group_id,\n                    fact: e.fact,\n                    fact_embedding: e.fact_embedding,\n                    episodes: e.episodes,\n                    expired_at: e.expired_at,\n                    valid_at: e.valid_at,\n                    invalid_at: e.invalid_at\n                })[..$limit] AS matches\n        '
2025-05-15 17:39:36,896 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: fact_embedding)} {position: line: 18, column: 39, offset: 852} for query: 'UNWIND $edges AS edge\n    MATCH (n:Entity)-[e:RELATES_TO {group_id: edge.group_id}]->(m:Entity)\n    WHERE n.uuid IN [edge.source_node_uuid, edge.target_node_uuid] OR m.uuid IN [edge.target_node_uuid, edge.source_node_uuid]\n            \n            WITH edge, e, vector.similarity.cosine(e.fact_embedding, edge.fact_embedding) AS score\n            WHERE score > $min_score\n            WITH edge, e, score\n            ORDER BY score DESC\n            RETURN edge.uuid AS search_edge_uuid,\n                collect({\n                    uuid: e.uuid,\n                    source_node_uuid: startNode(e).uuid,\n                    target_node_uuid: endNode(e).uuid,\n                    created_at: e.created_at,\n                    name: e.name,\n                    group_id: e.group_id,\n                    fact: e.fact,\n                    fact_embedding: e.fact_embedding,\n                    episodes: e.episodes,\n                    expired_at: e.expired_at,\n                    valid_at: e.valid_at,\n                    invalid_at: e.invalid_at\n                })[..$limit] AS matches\n        '
2025-05-15 17:39:36,896 - WARNING - Received notification from DBMS server: {severity: WARNING} {code: Neo.ClientNotification.Statement.UnknownPropertyKeyWarning} {category: UNRECOGNIZED} {title: The provided property key is not in the database} {description: One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: episodes)} {position: line: 19, column: 33, offset: 900} for query: 'UNWIND $edges AS edge\n    MATCH (n:Entity)-[e:RELATES_TO {group_id: edge.group_id}]->(m:Entity)\n    WHERE n.uuid IN [edge.source_node_uuid, edge.target_node_uuid] OR m.uuid IN [edge.target_node_uuid, edge.source_node_uuid]\n            \n            WITH edge, e, vector.similarity.cosine(e.fact_embedding, edge.fact_embedding) AS score\n            WHERE score > $min_score\n            WITH edge, e, score\n            ORDER BY score DESC\n            RETURN edge.uuid AS search_edge_uuid,\n                collect({\n                    uuid: e.uuid,\n                    source_node_uuid: startNode(e).uuid,\n                    target_node_uuid: endNode(e).uuid,\n                    created_at: e.created_at,\n                    name: e.name,\n                    group_id: e.group_id,\n                    fact: e.fact,\n                    fact_embedding: e.fact_embedding,\n                    episodes: e.episodes,\n                    expired_at: e.expired_at,\n                    valid_at: e.valid_at,\n                    invalid_at: e.invalid_at\n                })[..$limit] AS matches\n        '
2025-05-15 17:39:36,897 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:36,898 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:37,642 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:37,718 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:37,770 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:37,779 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:37,808 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:38,184 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:38,514 - INFO - Completed add_episode in 15750.36358833313 ms
2025-05-15 17:39:38,540 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:39,328 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:39,784 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:39,798 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:39,853 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:40,572 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:41,100 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:41,922 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:41,945 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:42,009 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:42,659 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:42,789 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:43,303 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:43,449 - INFO - Completed add_episode in 4935.091733932495 ms
2025-05-15 17:39:43,453 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:44,764 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 200 OK"
2025-05-15 17:39:45,540 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/embedding-001:batchEmbedContents "HTTP/1.1 200 OK"
2025-05-15 17:39:45,572 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:45,606 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:45,607 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:45,607 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:45,608 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:45,609 - INFO - AFC is enabled with max remote calls: 10.
2025-05-15 17:39:45,962 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 429 Too Many Requests"
2025-05-15 17:39:45,964 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 429 Too Many Requests"
2025-05-15 17:39:45,965 - INFO - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent "HTTP/1.1 429 Too Many Requests"
